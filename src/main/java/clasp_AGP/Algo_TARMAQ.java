package clasp_AGP;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import clasp_AGP.dataStructures.Item;
import clasp_AGP.dataStructures.abstracciones.ItemAbstractionPair;
import clasp_AGP.dataStructures.creators.AbstractionCreator;
import clasp_AGP.dataStructures.creators.AbstractionCreator_Qualitative;
import clasp_AGP.dataStructures.creators.ItemAbstractionPairCreator;
import clasp_AGP.dataStructures.database.SequenceDatabase;
import clasp_AGP.dataStructures.patterns.Pattern;
import clasp_AGP.idlists.IDList;
import clasp_AGP.savers.Saver;
import clasp_AGP.savers.SaverIntoFile;
import clasp_AGP.savers.SaverIntoMemory;
import clasp_AGP.tries.Trie;
import clasp_AGP.tries.TrieNode;
import clasp_AGP.tools.MemoryLogger;

/**
 * This is an implementation of the ClaSP algorithm. ClaSP was proposed by A.
 * Gomariz et al. in 2013.
 *
 * NOTE: This implementation saves the pattern to a file as soon as they are
 * found or can keep the pattern into memory, depending on what the user choose.
 *
 * Copyright Antonio Gomariz Pe√±alver 2013
 *
 * This file is part of the SPMF DATA MINING SOFTWARE
 * (http://www.philippe-fournier-viger.com/spmf).
 *
 * SPMF is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * SPMF is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * If not, see <http://www.gnu.org/licenses/>.
 *
 * @author agomariz
 */
public class Algo_TARMAQ {

    /**
     * The absolute minimum support threshold, i.e. the minimum number of sequences
     * where the patterns have to be
     */
    protected double minSupRelative;
    /**
     * Saver variable to decide where the user want to save the results, if it the
     * case
     */
    Saver saver = null;
    /**
     * Start and End points in order to calculate the overall time taken by the
     * algorithm
     */
    public long overallStart, overallEnd;
    /**
     * Start and End points in order to calculate the time taken by the main part of
     * CloSpan algorithm
     */
    protected long mainMethodStart;
    /**
     * Start and End points in order to calculate the time taken by the
     * post-processing method of CloSpan algorithm
     */
    protected long postProcessingStart;
    /**
     * Trie root that starts with the empty pattern and from which we will be able
     * to access to all the frequent patterns generated by ClaSP
     */
    protected Trie FrequentAtomsTrie;
    /**
     * Number of frequent patterns found by the algorithm
     */
    private int numberOfFrequentPatterns, numberOfFrequentClosedPatterns;

    protected List<TrieNode> itemConstraint;

    public long joinCount; // PFV 2013

    /**
     * Constructor of the class that calls ClaSP algorithm.
     *
     * @param abstractionCreator the abstraction creator
     * @param findClosedPatterns flag to indicate if we are interesting in only
     */
    public Algo_TARMAQ() {
    }

    /**
     * Actual call to ClaSP algorithm. The output can be either kept or ignore.
     * Whenever we choose to keep the patterns found, we can keep them in a file or
     * in the main memory
     *
     * @param database                  Original database in where we want to search
     *                                  for the frequent patterns.
     * @param keepPatterns              Flag indicating if we want to keep the
     *                                  output or not
     * @param outputFilePath            Path of the file in which we want to store
     *                                  the frequent patterns. If this value is
     *                                  null, we keep the patterns in the main
     *                                  memory. This argument is taken into account
     *                                  just when keepPatterns is activated.
     * @param outputSequenceIdentifiers indicates if sequence ids should be output
     *                                  with each pattern found.
     * @throws IOException
     */
    public void runAlgorithm(SequenceDatabase database, boolean keepPatterns, String outputFilePath,
            boolean outputSequenceIdentifiers) throws IOException {
        // If we do no have any file path
        if (outputFilePath == null || outputFilePath.equals("-")) {
            // The user wants to save the results in memory
            saver = new SaverIntoMemory(outputSequenceIdentifiers);
        } else {
            // Otherwise, the user wants to save them in the given file
            saver = new SaverIntoFile(outputFilePath, outputSequenceIdentifiers);
        }
        // reset the stats about memory usage
        MemoryLogger.getInstance().reset();
        // keeping the starting time
        overallStart = System.currentTimeMillis();
        // Starting ClaSP algorithm
        resultRanking(database, keepPatterns);

        // keeping the ending time
        overallEnd = System.currentTimeMillis();
        // Search for frequent patterns: Finished
        saver.finish();
    }

    /**
     * The actual method for extracting frequent sequences.
     *
     * @param database       The original database
     * @param keepPatterns   flag indicating if we are interested in keeping the
     *                       output of the algorithm
     */
    protected void resultRanking(SequenceDatabase database, boolean keepPatterns) {
        // We get the initial trie whose children are the frequent 1-patterns
        itemConstraint = database.itemConstraints();
        List<List<List<Item>>> rules = database.getRules();
        Map<Item, TrieNode> frequentItems = database.getFrequentItems();
        for (List<List<Item>> rule : rules) {
            List<Item> antecedent = rule.get(0);
            List<Item> consequent = rule.get(1);
            Pattern extension = new Pattern(new ArrayList<>());

            Item item = antecedent.get(0);
            ItemAbstractionPair newPair = ItemAbstractionPairCreator.getInstance().getItemAbstractionPair(
                    item, AbstractionCreator_Qualitative.getInstance().crearAbstraccion(true));
            extension.add(newPair);
            TrieNode itemNode = frequentItems.get(item);
            IDList newIdList = itemNode.getChild().getIdList();
            for (int i = 1; i < antecedent.size(); i++) {
                item = antecedent.get(i);
                itemNode = frequentItems.get(item);
                // And we add it the current item of itemset extension set
                newPair = ItemAbstractionPairCreator.getInstance().getItemAbstractionPair(
                        item, AbstractionCreator_Qualitative.getInstance().crearAbstraccion(true));
                extension.add(newPair);
                newIdList = newIdList.join(itemNode.getChild().getIdList(), true);
            }
            System.out.println(extension);
            System.out.println(newIdList.getSupport());
            System.out.println("===");
            
            item = consequent.get(0);
            newPair = ItemAbstractionPairCreator.getInstance().getItemAbstractionPair(
                    item, AbstractionCreator_Qualitative.getInstance().crearAbstraccion(true));
            extension.add(newPair);
            itemNode = frequentItems.get(item);
            newIdList = itemNode.getChild().getIdList();

            System.out.println(extension);
            System.out.println(newIdList.getSupport());
            System.out.println(" * * * * * * * * * * * * * * ");
        }
    }

    /**
     * Method to show the outlined information about the search for frequent
     * sequences by means of ClaSP algorithm
     *
     * @return
     */
    public String printStatistics() {
        StringBuilder r = new StringBuilder(200);
        r.append("=============  Algorithm - STATISTICS =============\n Total time ~ ");
        r.append(getRunningTime());
        r.append(" ms\n");
        r.append(" Frequent closed sequences count : ");
        r.append(numberOfFrequentClosedPatterns);
        r.append('\n');
        r.append(" Join count : ");
        r.append(joinCount);
        r.append(" Max memory (mb):");
        r.append(MemoryLogger.getInstance().getMaxMemory());
        r.append('\n');
        r.append(saver.print());
        r.append("\n===================================================\n");
        return r.toString();
    }

    public List<String> getResutl() {
        return saver.getList();
    }

    public int getNumberOfFrequentPatterns() {
        return numberOfFrequentPatterns;
    }

    public int getNumberOfFrequentClosedPatterns() {
        return numberOfFrequentClosedPatterns;
    }

    /**
     * It gets the time spent by the algoritm in its execution.
     *
     * @return
     */
    public long getRunningTime() {
        return (overallEnd - overallStart);
    }

    /**
     * It clears all the attributes of AlgoClaSP class
     */
    public void clear() {
        FrequentAtomsTrie.removeAll();
    }

    /**
     * Get the trie (internal structure used by ClaSP).
     * 
     * @return the trie
     */
    public Trie getFrequentAtomsTrie() {
        return FrequentAtomsTrie;
    }

}
